{"changed":false,"filter":false,"title":"chat.js","tooltip":"/chat.js","value":"/* chatURL - URL for updating chat messages */\nvar chatURL = \"chat.php\";\n/* getColorURL - URL for retrieving the chosen RGB color */\nvar getColorURL = \"get_color.php\";\n/* create XMLHttpRequest objects for updating the chat messages and getting the selected color */\nvar xmlHttpGetMessages = createXmlHttpRequestObject();\nvar xmlHttpGetColor = createXmlHttpRequestObject();\n/* variables that establish how often to access the server */\nvar updateInterval = 1000; // how many miliseconds to wait to get new message\n// when set to true, display detailed error messages\nvar debugMode = true;\n/* initialize the messages cache */\nvar cache = new Array();\n/* lastMessageID - the ID of the most recent chat message */\nvar lastMessageID = -1;\n/* mouseX, mouseY - the event's mouse coordinates */\nvar mouseX, mouseY;\n\n/* creates an XMLHttpRequest instance */\nfunction createXmlHttpRequestObject() {\n  // will store the reference to the XMLHttpRequest object\n  var xmlHttp;\n  // this should work for all browsers except IE6 and older\n  try {\n    // try to create XMLHttpRequest object\n    xmlHttp = new XMLHttpRequest();\n  }\n  catch (e) {\n    // assume IE6 or older\n    var XmlHttpVersions = new Array(\"MSXML2.XMLHTTP.6.0\",\n      \"MSXML2.XMLHTTP.5.0\",\n      \"MSXML2.XMLHTTP.4.0\",\n      \"MSXML2.XMLHTTP.3.0\",\n      \"MSXML2.XMLHTTP\",\n      \"Microsoft.XMLHTTP\");\n    // try every prog id until one works\n    for (var i = 0; i < XmlHttpVersions.length && !xmlHttp; i++) {\n      try {\n        // try to create XMLHttpRequest object\n        xmlHttp = new ActiveXObject(XmlHttpVersions[i]);\n      }\n      catch (e) {}\n    }\n  }\n  // return the created object or display an error message\n  if (!xmlHttp)\n    alert(\"Error creating the XMLHttpRequest object.\");\n  else\n    return xmlHttp;\n}\n\n/* this function initiates the chat; it executes when the chat page loads */\nfunction init() {\n  // get a reference to the text box where the user writes new messages\n  var oMessageBox = document.getElementById(\"messageBox\");\n  // prevents the autofill function from starting\n  oMessageBox.setAttribute(\"autocomplete\", \"off\");\n  // references the \"Text will look like this\" message\n  var oSampleText = document.getElementById(\"sampleText\");\n  // set the default color to black\n  oSampleText.style.color = \"black\";\n  // ensures our user has a default random name when the form loads\n  checkUsername();\n  // initiates updating the chat window\n  requestNewMessages();\n}\n\n// function that ensures that the username is never empty and if so \n// a random name is generated\nfunction checkUsername() {\n  // ensures our user has a default random name when the form loads\n  var oUser = document.getElementById(\"userName\");\n  if (oUser.value == \"\")\n    oUser.value = \"Guest\" + Math.floor(Math.random() * 1000);\n}\n\n/* function called when the Send button is pressed */\nfunction sendMessage() {\n  // save the message to a local variable and clear the text box\n  var oCurrentMessage = document.getElementById(\"messageBox\");\n  var currentUser = document.getElementById(\"userName\").value;\n  var currentColor = document.getElementById(\"color\").value;\n  // don't send void messages\n  if (trim(oCurrentMessage.value) != \"\" &&\n    trim(currentUser) != \"\" && trim(currentColor) != \"\") {\n    // if we need to send and retrieve messages\n    params = \"mode=SendAndRetrieveNew\" +\n      \"&id=\" + encodeURIComponent(lastMessageID) +\n      \"&color=\" + encodeURIComponent(currentColor) +\n      \"&name=\" + encodeURIComponent(currentUser) +\n      \"&message=\" + encodeURIComponent(oCurrentMessage.value);\n    // add the message to the queue\n    cache.push(params);\n    // clear the text box\n    oCurrentMessage.value = \"\";\n  }\n}\n\n/* function called when the Delete Messages button is pressed */\nfunction deleteMessages() {\n  // set the flag that specifies we're deleting the messages\n  params = \"mode=DeleteAndRetrieveNew\";\n  // add the message to the queue\n  cache.push(params);\n}\n\n/* makes asynchronous request to retrieve new messages, post new messages, delete messages */\nfunction requestNewMessages() {\n  // retrieve the username and color from the page\n  var currentUser = document.getElementById(\"userName\").value;\n  var currentColor = document.getElementById(\"color\").value;\n  // only continue if xmlHttpGetMessages isn't void\n  if (xmlHttpGetMessages) {\n    try {\n      // don't start another server operation if such an operation \n      //   is already in progress \n      if (xmlHttpGetMessages.readyState == 4 ||\n        xmlHttpGetMessages.readyState == 0) {\n        // we will store the parameters used to make the server request\n        var params = \"\";\n        // if there are requests stored in queue, take the oldest one\n        if (cache.length > 0)\n          params = cache.shift();\n        // if the cache is empty, just retrieve new messages        \n        else\n          params = \"mode=RetrieveNew\" +\n          \"&id=\" + lastMessageID;\n        // call the server page to execute the server-side operation\n        xmlHttpGetMessages.open(\"POST\", chatURL, true);\n        xmlHttpGetMessages.setRequestHeader(\"Content-Type\",\n          \"application/x-www-form-urlencoded\");\n        xmlHttpGetMessages.onreadystatechange = handleReceivingMessages;\n\n        xmlHttpGetMessages.send(params);\n      }\n      else {\n        // we will check again for new messages \n        setTimeout(\"requestNewMessages();\", updateInterval);\n      }\n    }\n    catch (e) {\n      displayError(e.toString());\n    }\n  }\n}\n\n/* function that handles the http response when updating messages */\nfunction handleReceivingMessages() {\n  // continue if the process is completed\n  if (xmlHttpGetMessages.readyState == 4) {\n    // continue only if HTTP status is \"OK\"\n    if (xmlHttpGetMessages.status == 200) {\n      try {\n        // process the server's response\n        readMessages();\n      }\n      catch (e) {\n        // display the error message\n        displayError(e.toString());\n      }\n    }\n    else {\n      // display the error message\n      displayError(xmlHttpGetMessages.statusText);\n    }\n  }\n}\n\n/* function that processes the server's response when updating messages */\nfunction readMessages() {\n  // retrieve the server's response \n  var response = xmlHttpGetMessages.responseText;\n  // server error?\n  if (response.indexOf(\"ERRNO\") >= 0 || response.indexOf(\"error:\") >= 0 || response.length == 0)\n    throw (response.length == 0 ? \"Void server response.\" : response);\n  // retrieve the document element\n  response = xmlHttpGetMessages.responseXML.documentElement;\n  // retrieve the flag that says if the chat window has been cleared or not \n  clearChat =\n    response.getElementsByTagName(\"clear\").item(0).firstChild.data;\n  // if the flag is set to true, we need to clear the chat window \n  if (clearChat == \"true\") {\n    // clear chat window and reset the id\n    document.getElementById(\"scroll\").innerHTML = \"\";\n    lastMessageID = -1;\n\n  }\n  // retrieve the arrays from the server's response     \n  idArray = response.getElementsByTagName(\"id\");\n  colorArray = response.getElementsByTagName(\"color\");\n  nameArray = response.getElementsByTagName(\"name\");\n  timeArray = response.getElementsByTagName(\"time\");\n  messageArray = response.getElementsByTagName(\"message\");\n  // add the new messages to the chat window\n  displayMessages(idArray, colorArray, nameArray, timeArray,\n    messageArray);\n  // the ID of the last received message is stored locally\n  if (idArray.length > 0)\n    lastMessageID = idArray.item(idArray.length - 1).firstChild.data;\n  // restart sequence\n  setTimeout(\"requestNewMessages();\", updateInterval);\n}\n\n/* function that appends the new messages to the chat list  */\nfunction displayMessages(idArray, colorArray, nameArray,\n  timeArray, messageArray) {\n  // each loop adds a new message\n  for (var i = 0; i < idArray.length; i++) {\n    // get the message details\n    var color = colorArray.item(i).firstChild.data.toString();\n    var time = timeArray.item(i).firstChild.data.toString();\n    var name = nameArray.item(i).firstChild.data.toString();\n    var message = messageArray.item(i).firstChild.data.toString();\n    // compose the HTML code that displays the message\n    var htmlMessage = \"\";\n    htmlMessage += \"<div class=\\\"item\\\" style=\\\"color:\" + color + \"\\\">\";\n    htmlMessage += \"[\" + time + \"] \" + name + \" said: <br/>\";\n    htmlMessage += message.toString();\n    htmlMessage += \"</div>\";\n    // display the message\n    displayMessage(htmlMessage);\n  }\n}\n\n// displays a message\nfunction displayMessage(message) {\n  // get the scroll object\n  var oScroll = document.getElementById(\"scroll\");\n  // check if the scroll is down\n  var scrollDown = (oScroll.scrollHeight - oScroll.scrollTop <=\n    oScroll.offsetHeight);\n  // display the message\n  oScroll.innerHTML += message;\n  // scroll down the scrollbar\n  oScroll.scrollTop = scrollDown ? oScroll.scrollHeight : oScroll.scrollTop;\n}\n\n// function that displays an error message\nfunction displayError(message) {\n  // display error message, with more technical details if debugMode is true\n  displayMessage(\"Error accessing the server! \" +\n    (debugMode ? \"<br/>\" + message : \"\"));\n}\n\n/* handles keydown to detect when enter is pressed */\n\nfunction handleKey(e) {\n  // get the event\n  e = (!e) ? window.event : e;\n  // get the code of the character that has been pressed        \n  code = (e.charCode) ? e.charCode :\n    ((e.keyCode) ? e.keyCode :\n      ((e.which) ? e.which : 0));\n  // handle the keydown event       \n  if (e.type == \"keydown\") {\n    // if enter (code 13) is pressed\n    if (code == 13) {\n      // send the current message  \n      sendMessage();\n    }\n  }\n}\n\n/* removes leading and trailing spaces from the string */\nfunction trim(s) {\n  return s.replace(/(^\\s+)|(\\s+$)/g, \"\")\n}\n\n/* function that computes the mouse's coordinates in page */\nfunction getMouseXY(e) {\n  // browser specific \n  if (window.ActiveXObject) {\n    mouseX = window.event.x + document.body.scrollLeft;\n    mouseY = window.event.y + document.body.scrollTop;\n  }\n  else {\n    mouseX = e.pageX;\n    mouseY = e.pageY;\n  }\n}\n\n/* makes a server call to get the RGB code of the chosen color */\nfunction getColor(e) {\n  getMouseXY(e);\n  // don't do anything if the XMLHttpRequest object is null\n  if (xmlHttpGetColor) {\n    // initialize the offset position with the mouse current position \n    var offsetX = mouseX;\n    var offsetY = mouseY;\n    // get references \n    var oPalette = document.getElementById(\"palette\");\n    var oTd = document.getElementById(\"colorpicker\");\n    // compute the offset position in our window\n    if (window.ActiveXObject) {\n      offsetX = window.event.offsetX;\n      offsetY = window.event.offsetY;\n    }\n    else {\n      offsetX -= oPalette.offsetLeft + oTd.offsetLeft;\n      offsetY -= oPalette.offsetTop + oTd.offsetTop;\n\n    }\n    // call server asynchronously to find out the clicked color\n    try {\n      if (xmlHttpGetColor.readyState == 4 ||\n        xmlHttpGetColor.readyState == 0) {\n        params = \"?offsetx=\" + offsetX + \"&offsety=\" + offsetY;\n        xmlHttpGetColor.open(\"GET\", getColorURL + params, true);\n        xmlHttpGetColor.onreadystatechange = handleGettingColor;\n        xmlHttpGetColor.send(null);\n      }\n    }\n    catch (e) {\n      // display error message\n      displayError(xmlHttp.statusText);\n    }\n  }\n}\n\n/* function that handles the http response */\nfunction handleGettingColor() {\n  // if the process is completed, decide to do with the returned data\n  if (xmlHttpGetColor.readyState == 4) {\n    // only if HTTP status is \"OK\"\n    if (xmlHttpGetColor.status == 200) {\n      try {\n        //change the color\n        changeColor();\n      }\n      catch (e) {\n        // display error message\n        displayError(xmlHttpGetColor.statusText);\n      }\n    }\n    else {\n      // display error message\n      displayError(xmlHttpGetColor.statusText);\n    }\n  }\n}\n\n/* function that changes the color used for displaying messages */\nfunction changeColor() {\n  response = xmlHttpGetColor.responseText;\n  // server error?\n  if (response.indexOf(\"ERRNO\") >= 0 || response.indexOf(\"error:\") >= 0 || response.length == 0)\n    throw (response.length == 0 ? \"Can't change color!\" : response);\n  // change color\n  var oColor = document.getElementById(\"color\");\n  var oSampleText = document.getElementById(\"sampleText\");\n  oColor.value = response;\n  oSampleText.style.color = response;\n}\n","undoManager":{"mark":-1,"position":-1,"stack":[]},"ace":{"folds":[],"scrolltop":0,"scrollleft":0,"selection":{"start":{"row":0,"column":0},"end":{"row":0,"column":0},"isBackwards":false},"options":{"guessTabSize":true,"useWrapMode":false,"wrapToView":true},"firstLineState":0},"timestamp":1443840715835}